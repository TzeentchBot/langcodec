use std::collections::HashMap;

use indoc::indoc;

use crate::{
    error::Error,
    traits::{Parser, ResourceConvertible},
    types::{Entry, EntryStatus, Metadata, Resource, Translation},
};

/// A parser for the Apple's .strings format.
///
/// The .strings format is a simple key-value pair format used for localization.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Format {
    pub language: String,
    pub pairs: Vec<Pair>,
}

impl Parser for Format {
    /// Creates a new `Format` instance with the specified language and pairs.
    ///
    /// The `language` parameter would be empty, since the .strings format does
    /// not contain any metadata about the language.
    fn from_reader<R: std::io::BufRead>(reader: R) -> Result<Self, Error> {
        let file_content = reader.lines().collect::<Result<Vec<_>, _>>()?.join("\n");

        // For simplicity, we assume there are no multi-line comments and in-line comments in the file.
        let lines = file_content.lines().collect::<Vec<_>>();

        let mut header = HashMap::<String, String>::new();

        let mut last_comment: Option<&str> = None;

        // strings pair pattern: "key" = "value";
        let pairs = lines
            .iter()
            .filter_map(|line| {
                let trimmed = line.trim();
                if trimmed.starts_with("//:") {
                    // This is a header line, we can extract metadata from it.
                    //
                    // Example: "//: Language: English"
                    let parts: Vec<&str> = trimmed.splitn(3, ':').collect();
                    if parts.len() == 3 {
                        let key = parts[1].trim().to_string();
                        let value = parts[2].trim().to_string();
                        header.insert(key, value);
                    }
                    return None; // Skip header lines
                } else if trimmed.is_empty()
                    || trimmed.starts_with("/*")
                    || trimmed.starts_with("//")
                {
                    last_comment = Some(trimmed);
                    return None; // Skip empty lines and comments
                }

                let parts: Vec<&str> = trimmed.splitn(3, '=').collect();
                if parts.len() != 2 {
                    return None; // Invalid line format
                }

                let key = parts[0].trim().trim_matches('"').to_string();
                let mut value = parts[1].trim().trim_matches(';').trim().to_string();
                value = value[1..value.len() - 1].to_string(); // Remove surrounding quotes

                Some(Pair {
                    key,
                    value,
                    comment: match last_comment {
                        Some(comment) if comment.starts_with("/*") || comment.starts_with("//") => {
                            Some(comment.trim().to_string())
                        }
                        _ => None,
                    },
                })
            })
            .collect();

        // Extract language from header if available
        let language = &header
            .get("Language")
            .cloned()
            .unwrap_or_else(|| String::new());

        Ok(Format {
            language: language.to_string(), // .strings format does not have a language field
            pairs: pairs,
        })
    }

    fn to_writer<W: std::io::Write>(&self, mut writer: W) -> Result<(), Error> {
        let mut content = String::new();

        let header = format!(
            indoc! {"
            // This file is automatically generated by langcodec.
            // Do not edit it manually, as your changes will be overwritten.
            // Here's the basic information about the file which could be useful
            // for translators, and langcodec would use it to generate the
            // appropriate metadata for the resource.
            //
            //: Language: {}
            //

            "},
            self.language
        );

        content.push_str(&header);

        for pair in &self.pairs {
            content.push_str(&pair.to_string());
            content.push('\n');
        }

        writer.write_all(content.as_bytes()).map_err(Error::Io)
    }
}

impl ResourceConvertible for Format {
    fn to_resource(&self) -> Result<Resource, Error> {
        Ok(Resource {
            metadata: Metadata::new(&self.language, "", &HashMap::new()),
            entries: self.pairs.iter().map(Pair::to_entry).collect(),
        })
    }

    fn from_resource(resource: &Resource) -> Result<Self, Error>
    where
        Self: Sized,
    {
        let pairs = resource
            .entries
            .iter()
            .map(Pair::from_entry)
            .collect::<Result<Vec<_>, _>>()?;

        Ok(Format {
            language: resource.metadata.language.clone(),
            pairs,
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Pair {
    pub key: String,
    pub value: String,
    /// Optional comment associated with the key-value pair.
    ///
    /// To keep it simple, we only support single-line comments in the form of `// comment` or `/* comment */`.
    /// And the comment marker is included in the comment field.
    pub comment: Option<String>,
}

impl Pair {
    fn to_entry(&self) -> Entry {
        Entry {
            id: self.key.clone(),
            value: Translation::Singular(self.value.clone()),
            comment: self.comment.clone(),
            status: if self.value.is_empty() {
                EntryStatus::New
            } else {
                EntryStatus::Translated
            },
            custom: HashMap::new(),
        }
    }

    fn from_entry(entry: &Entry) -> Result<Self, Error> {
        match &entry.value {
            Translation::Singular(value) => Ok(Pair {
                key: entry.id.clone(),
                value: value.clone(),
                comment: entry.comment.clone(),
            }),
            Translation::Plural(_) => Err(Error::DataMismatch(
                "Plural translations are not supported in .strings format".to_string(),
            )),
        }
    }
}

impl Pair {
    // Returns a comment without the comment marker.
    pub fn formatted_comment(&self) -> String {
        if let Some(comment) = &self.comment {
            if comment.starts_with("/*") && comment.ends_with("*/") {
                comment[2..comment.len() - 2].trim().to_string()
            } else if comment.starts_with("//") {
                comment[2..].trim().to_string()
            } else {
                comment.trim().to_string()
            }
        } else {
            String::new()
        }
    }

    fn to_string(&self) -> String {
        let mut result = format!("\"{}\" = \"{}\";", self.key, self.value);
        if let Some(comment) = &self.comment {
            result.insert_str(0, &format!("{}\n", comment));
        }
        result
    }
}
